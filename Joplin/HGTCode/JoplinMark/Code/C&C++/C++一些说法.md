---
title: C++一些说法
updated: 2022-09-21 08:49:27Z
created: 2022-09-21 08:36:34Z
---

# RTTI Run-Time Type Information
```
由于C++是静态类型语言，有关类的信息只在编译期被使用，编译后就不再保留，因此程序运行时无法获取类的信息。
这时就需要使用「运行期类型信息」，即RTTI（Run-Time Type Information）。
一般拥有程序运行时保存对象类型信息能力的语言，我们就称该语言支持RTTI。
C++标准定义了dynamic_cast和typeid两个关键字用于支持RTTI机制。

dynamic_cast的作用是将指向基类对象的指针转换为指向派生类对象的指针，如果转换失败则返回NULL。
因此，dynamic_cast唯一的功能就是判断一个对象具有哪些类型。
例如有4个类GrandFather、Father、Son和GrandSon，右边的类分别是左边类的派生类。
此时有一个类型为GrandFather *的指针p，为了判断p所指对象是否具有Son的类型，可以使用语句Son *son = dynamic_cast(p)。
如果返回的son不为NULL，则p所指的对象具有Son类型。同理我们也可以得到该对象是否具有Father、GrandSon类型.

但是仅仅知道这些是不够的。因为有时候某个指针所指的对象行为不正常，如果无法知道所指对象的实际类型，就必须审查该基类及其所有派生类的代码。
反过来，如果我们能够知道该对象的实际类型，那就只需要审查该类型的代码即可。
typeid的作用是返回类型的名字。
因此，typeid的功能就是在dynamic_cast的范围内进一步的确定指针所指对象的实际类型.

1.2 有限的RTTI能力

完整的描述一个类型需要很多信息，例如类的名字、有哪些父类、有哪些成员变量、有哪些成员函数、哪些是public的、哪些是private的、哪些是protected的等等。
有时候一个工程项目可能包含成千上万个类，完整的保存这些信息将会消耗大量的内存资源。
为了节省内存，C++标准约定typeid只能返回类名。因此，仅靠dynamic_cast和typeid两个关键字提供的类型信息实在有限。

即使仅提供有限的类型信息，RTTI的实现仍然耗费了很大的时间和存储空间，这就会降低程序的性能。
因此，早期的标准委员会并没有将该特性纳入C++中。
后来是出于以下的考虑才加入的：
（1）RTTI可以作为一个编译选项提供给开发人员。如果不需要用到这个特性，可以手动禁用这个特性。
（2）编译器只需要做很少的改动就可以实现RTTI。

另一方面，虽然C++定义了dynamic_cast和typeid两个关键字，但并没有说明如何实现这两个关键字。
这就造成了不同的编译器的实现不同，更别说提供RTTI功能的库千差万别。由此导致的最大问题就是程序的可移植性差，项目之间无法完美兼容。

为了解决这些问题，Qt没有采用C++的RTTI机制，却提供了更为强大的元对象（Meta-Object）系统机制来实现动态获取类型信息。

```

***
# 回调函数劣势弊端
```
在没有信号槽机制的时代，C++对象间的交互一般使用回调函数来实现。
使用某对象时，用指针指向另一个对象的函数，这个函数就称为回调函数。
使用回调函数有个弊端，当某个对象被多个对象通信时，需要一个容器来存放多个对象的回调函数。
维护这个容器使得代码编写效率低、扩展性弱。
```